public class WorkGit {
    public static void main(String[] args) {
        System.out.println("Мой проект!!!");


    /*СЕЙЧАС ВСЕ КОМАНДЫ, КОТОРЫЕ ПРИМЕНЯЛИ В ТЕРМИНАЛЕ, ПОСМОТРИМ В IDEA. А для этого создадим
    произвольный новый проект в IDEA "just_simple_project" и создадим в нём класс WorkGit. Итак,
    поехали.

    В IDEA в верхнем меню находим VCS, в выпадающем меню жмём самую верхнюю кнопку "Enable Version
    Control.....". В зависимости от версии. Но если не будет, можно в IDEA снизу жмякнуть
    "Version Control", вроде бы тоже самое будет. В окне выбираем версию Git. Наши файлы стали
    светиться красным.
    Далее заходим в раздел Commit в окне слева, либо в верхнем меню раздела Git. Файлы
    продолжают светиться красным. Помечаем те которые хотим ЗАКОМИТИТЬ.

    ВАЖНО!!! ФАЙЛЫ, КОТОРЫЕ НАХОДЯТСЯ В ПАПКЕ .idea, ни в коем случае не комитим, так как
    другой человек, который захочет открыть наш проект через IDEA не сможет туда зайти, ему
    придётся искать данную папку и удалять.

    А нас интересуют файлы WorkGit и pom.xml, их и будем комитить, помечаем галочкой и выделяем
    зажав Ctrl на клавиатуре. Далее правой кнопкой и выбираем Add to VCS (тоже самое, что в
    терминале мы нажимали git add .). Наши документы, которые мы выделяли, из красных, стали
    закрашены в зелёный цвет.

    САМОЕ ИНТЕРЕСНОЕ, ЧТО КОГДА МЫ БУДЕМ СМОТРЕТЬ ЭТИ ФАЙЛЫ, ТО ТАМ ЗЕЛЕНЫМ ЦВЕТОМ БУДУТ ВЫДЕЛЕНЫ
    ВСЕ ИЗМЕНЕНИЯ КОТОРЫЕ ВНЕСЛИ. СЕЙЧАС МЫ НЕ УВИДИМ, ТАК КАК ФАЙЛЫ НОВЫЕ И ИЗМЕНЕНИЙ НЕ БЫЛО.

    Далее комитим их. Для этого в разделе Changes выделяем их галочкой и нажимаем Commit
    (git commit -m "........." в терминале), но перед этим не забыть в поле Amend ввести
    название изменений. Далее из раздела Changes наши файлы пропали и наш созданный в самом
    начале класс WorkGit засветился белым цветом (до этого был синий)
    в .
    */

        System.out.println("Мой второй проект!!!");

        /*
        Если мы добавили что то в нашем проекте, т.е. внесли какие-либо изменения, то IDEA
        нам подсказывает об этом. А именно, в нашем классе появляется зелёный ползунок.
        Который будет в нашем файле, в тех строчках, где мы что добавляли или изменяли.
        Кроме того, если мы например изменим название класса, не сбоку, а прям в верхней строчке
        класса, то у строчки появится синий ползунок. И нажав на него, он покажет, что было
        до изменений и что стало после. Очень удобно. Зеленый обозначает что то новое.

        Если мы нажмём на кнопку Rollback Lines, то это посути отмена действий, и всё вернется
        как было. Причем выборочно, как для всего файла (слева на названии файла жмякнем
        Rollback), так и для одной строчки (подводим мышкой к данной строке и жмякаем
        Rollback Lines).

         Если нам нужно откатить файл до первоначального состояния, например который был
         неделю назад, то выделяем слева наш файл - Git - Show History. Где спокойно в истории
         откатим до нужного состояния.

         ВАЖНО!!! ЕСЛИ ВДРУГ ЗАБЫЛИ ЗАКОМИТИТЬ И ЧТО ТО СЛУЧАЛОСЬ С ФАЙЛОМ, ТО ТАКЖЕ МОЖНО
         ПОСМОТРЕТЬ НЕ ЗАКОМИЧЕННУЮ ИСТОРИЮ. ВЫДЕЛЯЕМ СЛЕВА НАШ ФАЙЛ - LOCAL HISTORY -
         Show History. ТАК ЖЕ ЕСТЬ ВСЕ ИЗМЕНЕНИЯ

         Ну а теперь создадим другую ветку. Для чего, под меню, рядом с названием проекта
          нажмем на название нашей текущей ветки (в нашем случае master), далее New branch,
          в поле вводим новое название ветки и на кнопку Create. После чего мы сразу автоматически
          переходим в новую ветку. А выпадающем списке видны все сущ. ветки.

          Переключаемся м/у ветками можно также как и в терминале с помощью кнопки checkout.
          Также есть кнопка Show Diff........ с помощью чего открывается два окна, и
          в одном из них подсвечивается, какие были изменения между ветками.

            Ещё один момент. ДАЖЕ НЕ ВСЕ ПРОГРАМИСТЫ ЗНАЮТ ПРО РАЗРЕШЕНИЕ КОНФЛИКТОВ

            Допустим, мы работаем на master ветке и она всегда главная 100%, либо Main. Добавляем
            там строку и делаем commit.
         */
        System.out.println("Эта строка в другой ветке");

        /*
        Перед тем, как её кому то показывать он должен убедиться, что его ветка актуальна. Т.е. он
        должен убедиться, что он отпачковался от самой последней версии master ветки. Если там что то
        поменялось, то он должен влить эти изменения из master в свою. Т.е. сделать МЁРДЖ (ОБНОВЛЕНИЕ).

        Живой пример, мы пишем сайт для тестирования формы авторизации на логи и пароль. Мы отпачковались
        от master, написали тест, и нам его необходимо влить в главную ветку master. Чтобы все видели
        мою работу. Перед этим необходимо убедиться, что мы актуализировали свою ветку. Зачем? А вот
        за чем. Допустим на master разработчики влили свежее изменение на прод, что для авторизации нужны не
        только логин и пароль, но и эл. почта. Поля теперь 3. Стоит ли теперь вливать мои тесты,
         где я не тестирую всего 2 поля? Конечно же нет. НАМ НУЖНО ВЕТКУ master ВЛИТЬ СЕБЕ И ДАЛЬШЕ
         СПОКОЙНО ДОПИСЫВАТЬ СВОЙ ТЕСТ.

         ДЕЛАТЬ ОБНОВЛЕНИЕ (МЁРДЖ) НЕОБХОДИМО РЕГУЛЯРНО, КАЖДОЕ УТРО, КАК ПРИХОДИМ НА РАБОТУ. ДЛЯ ЭТОГО
         НЕОБХОДИМО В ВЕРХНЕМ МЕНЮ НА НУЖНОЙ ВЕТКЕ НАЖАТЬ > "Merge "......" info ......", и он вольёт
         все актуальные изменения. (У МЕНЯ ТАКОЙ ВОЗМОЖНОСТИ НЕТ, ТАК КАК Я НЕ РАБОТАЮ ПО СЕТИ).
         ВОТ ЗДЕСЬ И МОЖЕТ ВОЗНИКНУТЬ КОНФЛИКТ, КОТОРЫй МНОГИЕ РЕШАТЬ НЕ УМЕЮТ. ДЛЯ ТОГО, ЧТОБЫ ЕГО
         РЕШИТЬ, НУЖНО В ПОЯВИВШЕМСЯ ОКНЕ Conflicts два раза кликнуть по конфликту. Там и должны
         посмотреть, что за конфликт. Например в нашем случае, в двух разных ветках мы написали
         на седьмой строке разный текст. И программа нам предлагает выбрать, какой же правильный.
         Если мы нажмем стрелочку, то вольется. А в другом нужно тогда нажать крестик. Или принимаем
         и там и там. Они встанут друг за другом. Далее нажимаем "Apply". Этот конфликт возник, так как
         два разработчика, в одной и той же строчке что то поменяли. Если бы изменения случились в разных
         строчках, т.е. один разраб в 4 ой, другой в 7 ой, то такого бы конфликта не случилось.

         НУ И ПОСЛЕДНЕЕ, САМОЕ ВАЖНОЕ, КАК ЖЕ ЗАГРУЗИТЬ НАШ ПРОЕКТ. ВОЗВРАЩАЕМСЯ В ВЕТКУ MASTER.
         НАХОДИМ НАШЕ ДОМАШНЕЕ ЗАДАНИЕ, ИЛИ АТТЕСТАЦИЮ НАПРИМЕР, КОТОРЫЕ НЕОБХОДИМО ЗАГРУЗИТЬ.
         Я КАК ПОЛАГАЕТСЯ СДЕЛАЛ COMMIT. СОТВЕТСТВЕННО МОИ ФАЙЛИКИ СТАЛИ БЕЛЕНЬКИЕ. ДАЛЕЕ НА КАКОМ ТО
         УДАЛЕННОМ РЕПОЗИТОРИИ ЧТОБЫ ТАМ ХРАНИТЬ НАШ ПРОЕКТ. ВЕДЬ НА ДАННЫЙ МОМЕНТ Git хранит всё локально.
         Т.е. только на нашем компьютере. И получается, если накроется жесткий диск, все данные,
         включая данные в Git, мы потеряем.
         ПОЭТОМУ ТАКОГО РОДА ДАННЫЕ, НЕОБХОДИМО ХРАНИТЬ НА УДАЛЁННОМ РЕПОЗИТОРИИ ТИПО Git Hab или
         Git lab.
         Для этого, заходим в Git Hab. Создаём новый репозиторий, нажатием на New. Называем
         его в окне Repository name, например attestationAndrei2412. Далее ничего не трогаем,
          проверяем что public и кликаем на "Create repository". Теперь ч/з idea можем поключиться
          к этому репозиторию и туда загрузить/запушить всё необходимое.
          Один из вариантов, это в idea в верхнем меню найти раздел Git -- Git Hub -- Share Project...
          и там в появившемся окне можно указать ссылку на проект. Но иногда idea начинает ругаться,
          что версия устарела, приходится устанавливать новую. ПОЭТОМУ ПРОСТО ИДЕМ В Git Hub
           И ДЕЛАЕМ ТО, ЧТО он НАМ И ПРЕДЛАГАЕТ. Копируем поочереди следующие три строчки и вставляем
           их в терминал idea (*слева внизу менюшка из четырех знаков, типо ветки, восклиц. знак в круге,
           шестигранник с треуг. внутри и квадрат с галочкой и черточкой. Его и ВЫБИРАЕМ. При наведении
            мышью на этот знак, будет написано терминал):

        ЧТО БЫЛО В ТЕРМИНАЛЕ:
        PS C:\Users\User\IdeaProjects\ untitled1>

        ЧТО ВСТАВЛЯЕМ ПООЧЕРЕДНО В ТЕРМИНАЛ, ПОСЛЕ ТОГО, ЧТО НАПИСАНО ВЫШЕ
        (сначала 1ю строку, далее Enter. 2ю - Enter, 3ю - Enter):

            git remote add origin https://github.com/Andrei-portfolio/Lesson-block-1.git
            git branch -M main
            git push -u origin main

    Обратим вниманее, что изначально наша ветка называлась master, после строк в терминале, стала main.
    После того, как вставили третью строку и нажали Enter, необходимо ввести логин и пароль от git hub.
    Кроме того, на электронную почту отправится письмо с разовым паролем. Его и необходиму будет ввести
    чтобы подтвердить, что это мой репозиторий, я владелец. Смотреть то его могут все, а вот записывать
    только я. Вот для чего.

    Семен вводил логин и пароль прям в терминале. А я прям в окне которое появилось. Кроме того, у Семена
    постоянно выдаёт ошибку, когда он вводит правильный логин и пароль. Поэтому не обращать на это вниманее.
    Так же у него не всегда срабатывает третья строчка, которую вставляли в терминал  "git push -u origin main".
    Поэтому в этом случае нужно в idea в меню найти раздел Git и самому нажать Push (либо Ctrl + Shift + K).
    Справа будут наши файлы (зеленым цветом), которые необходимо запушить и нежимаем Push. Далее переходим
    в Git Hub, обновляем страницу и проверяем наш проект.

    Далее в IDEA появляется НИК НЭЙМ с названием профиля в Git Hub, где после клика на него, видно,
    когда было запушено (У МЕНЯ НЕТ ТАКОГО). Данный НИК НЭЙМ задаётся в папке .gitignore на диске С,
    поидее он должен там сам появиться скорее всего с нашего акаунта idea, какой подключен, такой и будет.
    Ну а чтобы отправить ссылку с данным репозиторием, необходимо зайти в Git Hub и скопировать ссылку
    сверху

    ВРОДЕ БЫ ВСЁ!!!!!!!!!!!!!!!!!!!!!!
         */
    }
}
